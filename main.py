import multiprocessing
import subprocess
import time
import threading
import network_monitor
import file_monitor
import processess
import frontend
import os


def dir_name():

    try:
        with open("C:\\Users\\pranav\\PycharmProjects\\MalwareAnalyzere\\exe.txt", "r") as f:
            lines = f.readlines()
            last_line = lines[-1]
            last_line = last_line.strip()
        return last_line + '_malz'
    except FileExistsError:
        pass

def file_name():

    try:
        with open("C:\\Users\\pranav\\PycharmProjects\\MalwareAnalyzere\\exe.txt", "r") as f:
            lines = f.readlines()
            last_line = lines[-1]
            last_line = last_line.strip()
        return last_line
    except FileExistsError:
        pass
def execute_file(start_event, finish_event):
    start_event.wait()  # Wait for the start signal
    subprocess.run([f" C:\\Users\\pranav\\Desktop\\{dir_name()}"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    finish_event.set()  # Signal that the process has finished


def stop_processes_after_timeout(processes, timeout):
    def terminate_processes():
        for process in processes:
            process.terminate()

    timer = threading.Timer(timeout, terminate_processes)
    timer.start()


def main():

    try:
        os.mkdir(dir_name())
    except FileExistsError:
        pass
    os.chdir(dir_name())
    start_event = multiprocessing.Event()
    finish_event = multiprocessing.Event()

    execution_process = multiprocessing.Process(target=execute_file, args=(start_event, finish_event))
    monitoring_process = multiprocessing.Process(target=network_monitor.wire_cap)
    file_monitor_process = multiprocessing.Process(target=file_monitor.monitor_file)
    process_process = multiprocessing.Process(target=processess.process_list)

    monitoring_process.start()
    file_monitor_process.start()
    process_process.start()

    time.sleep(1)

    start_event.set()

    execution_process.start()

    # Stop the processes after 10 seconds.
    stop_processes_after_timeout([execution_process, monitoring_process, file_monitor_process, process_process], 10)

    # Wait for all processes to finish.
    execution_process.join()
    monitoring_process.join()
    file_monitor_process.join()
    process_process.join()



if __name__ == '__main__':
    frontend.create_login_window()
